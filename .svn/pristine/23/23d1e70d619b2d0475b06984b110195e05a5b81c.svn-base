using System.Collections;
using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// This class is essentially a collection of common nautical and rel-vel calculations
/// </summary>
public static class RelVelCalc
{
    /// <summary>
    /// self explanatory
    /// </summary>
    /// <param name="yards">The value in yards to be converted</param>
    /// <returns></returns>
    public static float Yards2NM(float yards)
    {
        return 0;
    }

    /// <summary>
    /// self explanatory
    /// </summary>
    /// <param name="NM">The value in nautical miles to be converted</param>
    /// <returns></returns>
    public static float NM2Yards(float NM)
    {
        return 0;
    }

    /// <summary>
    /// A function which takes an 2d direction and a magnitude and creates a vector
    /// </summary>
    /// <param name="angle">Any compass bearing between 0 and 360 deg</param> 
    /// <param name="magnitude">The magnitude of the vector. Eg. A velocity or distance</param> 
    /// <returns></returns>
    public static Vector2 AngleAndMagnitudeToVector2D(float angle, float magnitude)
    {
        //This ensures values in excess of 360 degrees are truncated to values that only appear on a compass ring, eg. 369 degrees becomes 9 degrees 720 degrees becomes 0  degrees, etc... I will also clamp the input value so it doesn't exceed 360, this is just an added layer of protection
        if (angle >= 360)
        {
            angle = angle % 360;
        }

        float angleInRads = angle * Mathf.Deg2Rad;
        Vector2 outputVector = new Vector2();
        outputVector.x = Mathf.Sin(angleInRads);
        outputVector.y = Mathf.Cos(angleInRads);
        outputVector = outputVector * magnitude;
        return outputVector;
    }

    /// <summary>
    /// Calculates the true bearing and range of one object from another
    /// </summary>
    /// <param name="bearingFrom">the object from which the bearing and range is being measured</param>
    /// <param name="bearingTo">the object to which the bearing and range is being measured</param>
    /// <param name="bearing">the bearing between objects</param>
    /// <param name="range">the range between objects</param>
    public static void TrueBearingAndRangeFrom(Vector3 bearingFrom, Vector3 bearingTo, out float bearing, out float range)
    {
        Vector2 fromObject;
        Vector2 toObject;

        fromObject.x = bearingFrom.x;
        fromObject.y = bearingFrom.z;

        toObject.x = bearingTo.x;
        toObject.y = bearingTo.z;

        Vector2 bearingVector = toObject - fromObject;


        bearing = (Mathf.Rad2Deg * Mathf.Atan2(bearingVector.x, bearingVector.y));
        range = Vector3.Distance(bearingFrom, bearingTo);
        if (bearing < 0)
        {
            bearing += 360;
        }
    }


    /// <summary>
    /// A method which calculates the key range and bearing of a relvel solution, the point along the line of a ships relative movement where it must return to its base course
    /// </summary>
    /// <param name="offset">The Advance, DNC, or Transfer of the turn in yards</param>
    /// <param name="GuideCRS">The guides present course</param>
    /// <param name="GuideBears">what the guide bears at the beginning of the maneuver</param>
    /// <param name="RangeToGuide">the range to the guide at the beginning of the maneuver</param>
    /// <param name="GuideWIllBear">What the Guide will bear at the end of the maneuver</param>
    /// <param name="NewRangeToGuide">The range to the guide at the end of the maneuver</param>
    public static void CalculateKeyRangeAndBearing(float offset, float GuideCRS, float GuideBears, float RangeToGuide, float GuideWIllBear, float NewRangeToGuide, out float keyRange, out float keyBearing)
    {
        //Debug.Log("offset: " + offset.ToString());
        //establish the start and end points
        Vector2 relStart = AngleAndMagnitudeToVector2D(GuideBears - GuideCRS, RangeToGuide);
        Vector2 relEnd = AngleAndMagnitudeToVector2D(GuideWIllBear - GuideCRS, NewRangeToGuide);

        //find the slope of the line between two points (the relative)
        Vector2 relativeDelta = relEnd - relStart;

        //take the overall length of this line and subtract advance/transfer/dnc (offset)
        float magnitude = relativeDelta.magnitude - offset;
        

        //build a new line using the normalized slope of the old line and the calculated length of the new line
        Vector2 tempRelative = relativeDelta.normalized;
        tempRelative = tempRelative * magnitude;

        //fuck I should have paid closer attention in grade 12 calculus... this finds the end point of the line... I think?
        Vector2 finalPoint = tempRelative + relStart;
        //Debug.Log(finalPoint);
        //the angle from the origin to this point is the key bearing, and the distance from the origin to this point should be key range...
        keyRange = Vector2.Distance(Vector2.zero, finalPoint);
        keyBearing = Mathf.Rad2Deg * (Mathf.Atan2(finalPoint.x, finalPoint.y));
        if (keyBearing < 0)
        {
            keyBearing += 360;
        }
    }

    private static void CalculateAdvanceAndTransfer(float baseCrs, Vector3 turnStartPosition, Vector3 turnEndPosition, out float advance, out float transfer, out float dnc)
    {
        //find theta, unity's sin and cosine functions use radians, we must find the angle between the base course and the new course
        Vector2 direction = new Vector2(turnEndPosition.x - turnStartPosition.x, turnEndPosition.z - turnStartPosition.z);
        float thetaInRads = ((Mathf.Deg2Rad * baseCrs) - Mathf.Atan2(direction.x, direction.y)) * -1f;

        //The hypotenuse will always just be the distance between when the turn begins and ends (DNC)
        float hypotenuse = Vector3.Distance(turnStartPosition, turnEndPosition);

        //the rest can be found with trig
        float opposite = Mathf.Sin(thetaInRads) * hypotenuse;
        float adjancent = Mathf.Cos(thetaInRads) * hypotenuse;

        //assign the corresponding parts of the triangle to the relevent measurements
        advance = adjancent;
        transfer = opposite;
        dnc = hypotenuse;
    }

    /// <summary>
    /// Vector math and trigenometry are  used to determine which course and speed are needed to complete the maneuver
    /// </summary>
    //public static void CalculateRVel()
    //{
    //    solutionExists = false;

    //    //Calculate the distance and angle of the relative
    //    float GuideSPD = GuideInfo.Instance.guideSpd;

    //    Vector2 guideCrsAndSpd = new Vector2();
    //    Vector2 guidePos = new Vector2();
    //    Vector2 guideWillBear = new Vector2();


    //    guideCrsAndSpd = AngleAndMagnitudeToVector2D(GuideInfo.Instance.guideCRS, GuideInfo.Instance.guideSpd);
    //    guidePos = AngleAndMagnitudeToVector2D(GuideInfo.Instance.guideBears, GuideInfo.Instance.rangeToGuide);
    //    guideWillBear = AngleAndMagnitudeToVector2D(GuideInfo.Instance.guideWillBear, GuideInfo.Instance.newRangeToGuide);

    //    float relDistance = Vector2.Distance(guidePos, guideWillBear);

    //    //find the cartesian slope of the relative
    //    Vector2 direction = guideWillBear - guidePos;

    //    //convert the slope into degrees
    //    float relAngle = Mathf.Atan2(direction.x, direction.y) * Mathf.Rad2Deg;
    //    if (relAngle < 0)
    //    {
    //        relAngle += 360;
    //    }

    //    //Convert relative slope to same scale as guide velocity, assume 100:1 scale for now CHANGE LATER
    //    direction = direction / 100;

    //    //Calculate the Course to Steer
    //    //We need the reciprocal of the relative direction vector, it works on the relvel board, but not for vector addition equations
    //    direction = direction * -1;

    //    //find the angle between the guide course and speed velocity vector and the relative course and speed velocity vector
    //    Vector2 test = new Vector2();
    //    test = guideCrsAndSpd * -1;

    //    float angleOne = Mathf.Atan2(test.x, test.y) * Mathf.Rad2Deg;
    //    if (angleOne < 0)
    //    {
    //        angleOne += 360;
    //    }
    //    float angleTwo = Mathf.Atan2(direction.x, direction.y) * Mathf.Rad2Deg;
    //    float angleTheta = angleOne - angleTwo;
    //    // print(angleTheta);

    //    //Now we can use Sin law to find the optimal relative velocity vector for standard solution
    //    //Initialize the variables, We know two sides and one angle in advance
    //    float A = 0;
    //    float B = 0;
    //    float C = angleTheta;
    //    float a = 0;
    //    float b = guideCrsAndSpd.magnitude;
    //    float c = 0;

    //    //refactor this code later to make it more neat
    //    if (DesiredSpeed.value == 0)
    //    {
    //        c = SSpeed;
    //    }
    //    else if (DesiredSpeed.value == 1)
    //    {
    //        c = GuideSPD;
    //    }
    //    else if (DesiredSpeed.value == 2)
    //    {
    //        c = 4;
    //    }
    //    else
    //    {
    //        print("Possible off by one or null reference error for desired speed");
    //    }


    //    //solve for the sin constant
    //    float constant = c / Mathf.Sin(C * Mathf.Deg2Rad);
    //    //Now we have enough variables to solve for angle B
    //    B = Mathf.Asin(b / constant) * Mathf.Rad2Deg;
    //    //now we can find the missing angle A
    //    A = 180 - (B + C);
    //    //now we have enough information to Solve for a
    //    a = Mathf.Sin(A * Mathf.Deg2Rad) * constant;

    //    //adjust the direction vector for optimal speed
    //    Vector2 speedAdjust = direction.normalized * a;
    //    CTS = guideCrsAndSpd + speedAdjust;

    //}

    //public static void SanityCheck()
    //{
    //    //sanity check to ensure valid numbers are being output
    //    if (float.IsNaN(CTS.x) || float.IsNaN(CTS.y) || float.IsNaN(c))
    //    {
    //        return;
    //    }

    //    CTSAngle = (Mathf.Atan2(CTS.x, CTS.y) * Mathf.Rad2Deg);
    //    if (CTSAngle < 0)
    //    {
    //        CTSAngle += 360;
    //    }

    //    VectorDisplay.editTrueCTSVector(AngleAndMagnitudeToVector2D(CTSAngle - GuideCRS, c));

    //    //Quick sanity check to eliminate revel solutions which do not result in a course or speed alteration. (this can occur when for example, the starting bearing and destination bearing are set to be the same, or in cases where the relvel "triangle" calculated  is actually a straight line)
    //    float angleCheck = GuideCRS - CTSAngle;
    //    angleCheck = Mathf.Abs(angleCheck);
    //    float speedCheck = GuideSPD - CTS.magnitude;
    //    speedCheck = Mathf.Abs(speedCheck);

    //    //check to see if there is any appreciable change in course or speed, if neither has changed, then no solution exists for the given parameters
    //    if (angleCheck > 1f || speedCheck > 1f)
    //    {
    //        CTSAngle = Mathf.Round(CTSAngle);
    //        float roundedSpeed = Mathf.Round(CTS.magnitude);
    //        if (CTSAngle < 100)
    //        {
    //            CTSText.text = "CTS: 0" + CTSAngle.ToString() + "°";
    //            SpeedText.text = "SPD: " + roundedSpeed.ToString() + "KTS";
    //        }
    //        else
    //        {
    //            CTSText.text = "CTS: " + CTSAngle.ToString() + "°";
    //            SpeedText.text = "SPD: " + roundedSpeed.ToString() + "KTS";
    //        }

    //        solutionExists = true;
    //        ExecuteButton.interactable = true;
    //    }
    //    else
    //    {
    //        //change this to a popup message once that functionality is in place
    //        print("error! the paramers entered do not allow for a valid relvel solution (physically impossible)");
    //        ResetInterfaceText();
    //        solutionExists = false;
    //        ExecuteButton.interactable = false;
    //    }

    //}
}
